from typing import Any, Dict, List, Optional, Tuple
import os
from datetime import datetime

import certifi
from pymongo import MongoClient

from telemedicine.core.base import (
    openai_embedding,
    Message,
    calculate_similarity
)
from telemedicine.core.translate import translate
from telemedicine.retrievers import Retrieval


class Chat:
    """
    Class to manage chat interactions and retrieve information from documents.
    """
    
    def __init__(self):
        self.history = []
        

    def add_history(self, 
                    message_type: str, 
                    message: str) -> Message:
        """
        Add a message to the chat history.

        Args:
            message_type (str): The type of the message (e.g., 'user', 'assistant').
            message (str): The content of the message.
            message_embedding (List[float], optional): The embedding of the message. Defaults to None.

        Returns:
            None
        """

        conversation_index = self.get_last_conversation_index()
        message_id = f'{message_type}_{conversation_index}'
        timestamp = datetime.now()
        message = Message(
            message_id=message_id,
            conversation_index=conversation_index,
            timestamp=timestamp,
            message_type=message_type,
            message_str=message
        )
        self.history.append(message)
        return message


    def get_last_conversation_index(self) -> int:
        """
        Get the index of the last conversation in the chat history.

        Returns:
            int: The index of the last conversation.
        """

        index = 0
        if len(self.history) > 0:
            for message in self.history:
                if message.conversation_index > index:
                    index = message.conversation_index
                    message_type = message.message_type
                    if message_type == 'assistant':
                        index += 1
        return index
    

    def get_message_pair_by_index(self, index: int) -> Tuple[str, str]:
        """
        Get a pair of messages (user and assistant) by conversation index.

        Args:
            index (int): The conversation index.

        Returns:
            Tuple[str, str]: A tuple containing the user message and the assistant message.
        """

        assistant_message = None
        user_message = None
        for message in self.history:
            if message.conversation_index == index:
                if message.message_type == 'assistant':
                    assistant_message = message
                elif message.message_type == 'user':
                    user_message = message
        return user_message, assistant_message
    

    def get_n_last_message_pair(self, num_messages: int) -> str:
        """
        Get the last n pairs of messages (user and assistant) from the chat history.

        Args:
            num_messages (int): The number of message pairs to retrieve.

        Returns:
            str: A string representation of the last n message pairs.
        """

        assistant_messages = [message for message in self.history if message.message_type == 'assistant']
        message_pair_str = ''
        n_messages = min(num_messages, len(assistant_messages))
        for message in assistant_messages[-n_messages:]:
            index = message.conversation_index
            user_message, assistant_message = self.get_message_pair_by_index(index)
            message_pair_str += user_message.get_message_dialogue() + '\n'
            message_pair_str += assistant_message.get_message_dialogue() + '\n'
        return message_pair_str


    def get_response(self, question: str, session_id: str) -> str:
        """
        Process the given question and retrieve the appropriate response.
        This method wraps several interaction with the retrievers agent.

        Args:
            question (str): The question to process and retrieve the response for.

        Returns:
            str: The response generated by the retrieval process.
        """
        _ = self.add_history('user', question)
        response, token_usage = self.get_answers(question)
        message_obj = self.add_history('assistant', response)
        message_obj = message_obj.get_dict()
        record_usage(token_usage, session_id, message_obj["message_id"], message_obj["timestamp"])
        return response
    

    def get_answers(self, question: str) -> str:
        """
        Retrieval agent to retrieve the final answers from the documents for the given question.

        Args:
            question (str): The refined question.
            question_embedding (List[float]): The embedding of the question.

        Returns:
            str: The final answers from the documents.
        """

        history = self.get_n_last_message_pair(2)
        response_text, token_usage = Retrieval.retrieve(
            question=question, 
            history=history,
            return_usage=True
        )
        response_text = translate(response_text, "auto", "id")
        return response_text, token_usage
    
    def __call__(self, question: str, session_id) -> str:
        return self.get_response(question, session_id)
    


def record_usage(usage_data, session_id, message_id, timestamp):
    mongo_uri = os.getenv('MONGO_URI')
    client = MongoClient(mongo_uri, tlsCAFile=certifi.where())
    db_name = os.getenv('MONGO_DB_SESSION')
    collection_name = os.getenv('MONGO_COLLECTION_USAGE')
    collection = client[db_name][collection_name]

    for usage in usage_data:
        collection.insert_one(
            {
                'session_id': session_id, 
                'message_id': message_id,
                'timestamp': timestamp,
                'prompt_tokens': usage.prompt_tokens,
                'completion_tokens': usage.completion_tokens,
                'total_tokens': usage.total_tokens,
                'model_name': usage.model_name
            }
        )